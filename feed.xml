<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://explain.yshui.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://explain.yshui.dev/" rel="alternate" type="text/html" /><updated>2021-07-11T13:16:57-05:00</updated><id>https://explain.yshui.dev/feed.xml</id><title type="html">Explain Algorithms</title><subtitle>Computer algorithms in human readable format</subtitle><entry><title type="html">Handle C++ exceptions in C code, part 1</title><link href="https://explain.yshui.dev/programming%20language/2020/10/16/exceptions.html" rel="alternate" type="text/html" title="Handle C++ exceptions in C code, part 1" /><published>2020-10-16T00:00:00-05:00</published><updated>2020-10-16T00:00:00-05:00</updated><id>https://explain.yshui.dev/programming%20language/2020/10/16/exceptions</id><content type="html" xml:base="https://explain.yshui.dev/programming%20language/2020/10/16/exceptions.html">&lt;p&gt;Hold on! Before you call me crazy, please let me clarify. Yes, I am going to tell you how to handle C++ exceptions in C code,
but don't worry, I know this is a terrible idea, and (hopefully) no one is &lt;em&gt;actually&lt;/em&gt; going to do that.&lt;/p&gt;

&lt;p&gt;But why, you might ask, would anyone even begin to ponder such a silly idea? Well, poking things and making them do things they
aren't &lt;em&gt;supposed to&lt;/em&gt; do is a excellent way to figure out how they work. And exception handling is certainly a very interesting
, and perhaps quite important, practical &lt;strong&gt;computer algorithm&lt;/strong&gt;. So it's quite natural for someone to have curiosity about how it works.&lt;/p&gt;

&lt;p&gt;Alright. But where do we even start? If you search for information on exception handling online, what you would find is
usually cryptic and incomplete documentation about ELF, Dwarf, and C++ ABI. Often they are difficult to understand, and it
is usually hard for someone to see how they all fit together.&lt;/p&gt;

&lt;p&gt;So instead, let's work in reverse. Let's inspect something that actually does exception handling.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;throw_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;throw_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is a baseline program that throws an exception and catches it. Let's try compiling it and see what comes out:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g++ code.cc &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you are wondering what &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-S&lt;/code&gt; does, it tells the compiler to stop after producing the assembly, without assembling or linking the code.
You should try this step yourself, and look at the assembly produced. Here, I picked out a few relevant snippets, and simplified them to
make them easier to read.&lt;/p&gt;

&lt;p&gt;Let's look at the throwing side first:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;throw_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.LFB0:&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;push&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rbp&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rbp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rsp&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;edi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;__cxa_allocate_exception@PLT&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; &amp;lt;----&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;QWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;lea&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;_ZTIDn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;__cxa_throw@PLT&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;; &amp;lt;----&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you are not used to looking at assembly, this might look quite daunting. But luckily, you don't have to know any assembly at all to pick out the interesting bits here:
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cxa_allocate_exception&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cxa_throw&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As their names suggest, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cxa_allocate_exception&lt;/code&gt; allocates space for the thrown exception, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cxa_throw&lt;/code&gt; actually commences the throwing.
(the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cxa_&lt;/code&gt; bit probably means &quot;cxx abi&quot;, I am not sure.) You don't have to take my words, you can find this information &lt;a href=&quot;https://libcxxabi.llvm.org/spec.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are curious, you can find the code of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cxa_throw&lt;/code&gt; &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/a16da48bf19bb139e5461e5b5b7f072d5369b054/libstdc%2B%2B-v3/libsupc%2B%2B/eh_throw.cc#L75&quot;&gt;here&lt;/a&gt;.
For the rest of us, we will move on to the catching side:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;main:&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.LFB1:&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;push&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rbp&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rbp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rsp&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.LEHB0:&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;throw_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.LEHE0:&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.L6:&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;jmp&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;.L8&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; &amp;lt;- this will jump to the label below&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.L7:&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;je&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;.L5&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.LEHB1:&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;_Unwind_Resume@PLT&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.LEHE1:&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.L5:&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;__cxa_begin_catch@PLT&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;QWORD&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rbp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;__cxa_end_catch@PLT&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;jmp&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;.L6&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.L8:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; &amp;lt;- this is a label&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;leave&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; &amp;lt;- this means &quot;return&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(If you don't know how to read this assembly, you just need to know this: instructions which start with letter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt; mean jump. The thing which follows the jump instruction is a &quot;label&quot;, which is also what the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.Lxxx:&lt;/code&gt; you see in the code are.
The jump instruction will jump to the matching label when executed)&lt;/p&gt;

&lt;p&gt;OK, here we spot &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cxa_begin_catch&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cxa_end_catch&lt;/code&gt;, which seems to match the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;catch&lt;/code&gt; block in the source code. However, they don't seem to be reachable. If you follow the call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;throw_exception()&lt;/code&gt;,
you can see after it returns, the code immediately jumps to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.L8&lt;/code&gt;, which returns to the caller. So who is going to trigger the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;catch&lt;/code&gt; block?&lt;/p&gt;

&lt;p&gt;Let's look a bit further into the assembly:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;.LFE1:&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.globl&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;__gxx_personality_v0&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.section&lt;/span&gt;        &lt;span class=&quot;nv&quot;&gt;.gcc_except_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;progbits&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.align&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.LLSDA1:&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.byte&lt;/span&gt;   &lt;span class=&quot;mh&quot;&gt;0xff&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.byte&lt;/span&gt;   &lt;span class=&quot;mh&quot;&gt;0x9b&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.uleb128&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;.LLSDATT1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;.LLSDATTD1&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.LLSDATTD1:&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.byte&lt;/span&gt;   &lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.uleb128&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;.LLSDACSE1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;.LLSDACSB1&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.LLSDACSB1:&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.uleb128&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;.LEHB0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;.LFB1&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.uleb128&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;.LEHE0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;.LEHB0&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.uleb128&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;.L7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;.LFB1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; &amp;lt;- ha&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.uleb128&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.uleb128&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;.LEHB1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;.LFB1&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.uleb128&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;.LEHE1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;.LEHB1&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.uleb128&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;.uleb128&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This assembly block defines &lt;em&gt;data&lt;/em&gt;. After being assembled and linked, they become data bytes stored verbatim in the executable. And in there, we find a reference to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.L7&lt;/code&gt;.
Look back at the code, we can see &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.L7&lt;/code&gt; contains a jump to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.L5&lt;/code&gt;, which is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;catch&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;From this, we can infer that, there is some information stored in the executable (&quot;metadata&quot;), which, when an exception is thrown, the throwers will read to figure out the code to run.&lt;/p&gt;

&lt;p&gt;Alright, now we have a &lt;span id=&quot;rough&quot; class=&quot;anchor&quot;&gt;rough&lt;/span&gt; picture of how exception handling works:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The thrower prepares the exception, then call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cxa_throw&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cxa_throw&lt;/code&gt; looks through the metadata of the callers in the function call stack, to find a suitable handler&lt;/li&gt;
  &lt;li&gt;The program jumps to the handler&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Looks simple, right? If we can &lt;em&gt;somehow&lt;/em&gt; make the metadata of a &lt;em&gt;C&lt;/em&gt; function declare: &quot;hey, look here, I have an exception handler!&quot;, we will be done.&lt;/p&gt;

&lt;p&gt;But, as you might know, there is no such thing as exceptions in the C language. There can't possibly be a way to declare a function as having an exception handler, right?&lt;/p&gt;

&lt;p&gt;Well, there is not a &lt;em&gt;standard&lt;/em&gt; way. But there is a way. There is this extension to C, implemented by the GCC compiler (and later Clang), which allows you to attach a
&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Common-Variable-Attributes.html#:~:text=cleanup&quot;&gt;&quot;cleanup&quot;&lt;/a&gt; function to a local variable. This cleanup function will be called when
the local variable goes out of scope.&lt;/p&gt;

&lt;p&gt;Because of the excellent interoperability between C and C++, you can have the situation where an C++ exception is thrown &quot;through&quot; a C function. Normally, the cleanup functions
aren't going to run in that case. However, this makes people unhappy. So, now, there &lt;em&gt;is&lt;/em&gt; a way to make them run.&lt;/p&gt;

&lt;p&gt;Passing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-fexceptions&lt;/code&gt; option to GCC, makes it generate exception-aware code even when compiling C code. And in that mode, the cleanup functions will be registered as exception handlers! Just like the local variable destructors in C++.&lt;/p&gt;

&lt;p&gt;Here is an example:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// file1.cc&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;throw_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;might_throw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// OK, we have to have a try/catch in main,&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// because if C++ cannot find an actual `catch` block,&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// it will just abort(), without going through the throw&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// process at all.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;might_throw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// file2.c&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;throw_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;the_cleanup_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cleanup called&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;might_throw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Call the_cleanup_function when `x` goes out of scope&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;the_cleanup_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;throw_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;do more stuff&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we don't get to this point :'(&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Compile and run:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g++ file1.cc &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt;
gcc file2.c &lt;span class=&quot;nt&quot;&gt;-fexceptions&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt;
g++ file1.o file2.o
./a.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You will see it says:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;cleanup called
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you look at the assembly of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file2.c&lt;/code&gt;, you will see structures very similar to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try/catch&lt;/code&gt; block in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file1.cc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;OK, we are able to get a C function called during the handling of a &lt;em&gt;C++&lt;/em&gt; exception. But this exception still propagated through the C function, which is
normal, given we didn't actually catch the signal. But what exactly is going on here? How did the control flow slip away from our hands?&lt;/p&gt;

&lt;p&gt;Let's look at the assembly again:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;might_throw:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; ... skipped ...&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.L7:&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rbp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;jmp&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;.L5&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.L5:&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;lea&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;.LEHB2:&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;the_cleanup_function&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;	&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rbp&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;	&lt;span class=&quot;nv&quot;&gt;_Unwind_Resume@PLT&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;; ... more skipped ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can easily see the call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;the_cleanup_function&lt;/code&gt;, right after that, is a call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_Unwind_Resume&lt;/code&gt;. What does that do?&lt;/p&gt;

&lt;p&gt;First of all, what does &quot;unwind&quot; mean here? You might have already known, the program needs to &quot;unwind its stack&quot; when an exception is thrown. Basically it has to remove entries on its call stack, until a handler is found.
Which is the process we already described &lt;a href=&quot;#rough&quot;&gt;above&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, inferring from the function name again, we can guess that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_Unwind_Resume&lt;/code&gt; resumes an interrupted stack unwinding (which is, by the way,
&lt;a href=&quot;https://web.archive.org/web/20201016174844id_/https://refspecs.linuxfoundation.org/LSB_4.0.0/LSB-Core-S390/LSB-Core-S390/baselib--unwind-resume.html&quot;&gt;correct&lt;/a&gt;).
And our cleanup function does interrupt the unwind, so after the cleanup function returns, the program calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_Unwind_Resume&lt;/code&gt; to resume the unwinding.&lt;/p&gt;

&lt;p&gt;Alright, &lt;em&gt;if&lt;/em&gt;, we can stop that function from being called. If we can do that, we would have &quot;caught&quot; the exception.&lt;/p&gt;

&lt;p&gt;Basically, we want &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;the_cleanup_function&lt;/code&gt; to skip over everything in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;might_throw&lt;/code&gt; that is after the call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;the_cleanup_function&lt;/code&gt;. Clearly, we need something that could interrupt the normal execution flow of the program.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;goto&lt;/code&gt; is not enough, because our skip is cross-function. We need something stronger.&lt;/p&gt;

&lt;p&gt;And there is indeed something stronger. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setjmp&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;longjmp&lt;/code&gt;! A call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;longjmp&lt;/code&gt; allows you to jump to a point in the program where you have previously called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setjmp&lt;/code&gt; (the
&lt;a href=&quot;https://man7.org/linux/man-pages/man3/setjmp.3.html&quot;&gt;man page&lt;/a&gt; explains these functions very well). So we just need to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setjmp&lt;/code&gt; to put an anchor in the normal return path of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;might_throw&lt;/code&gt;, then have
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;the_cleanup_function&lt;/code&gt; jump to there with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;longjmp&lt;/code&gt;, and we would have skipped the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_Unwind_Resume&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is a version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;might_throw&lt;/code&gt; that does this:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;setjmp.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;jmp_buf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// The cleanup function will be called when the exception is thrown,&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// but then it will be called again when we return from `might_throw`.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// We don't want it to perform the longjmp when `might_throw` is returning&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// normally, so we use a flag to indicate whether a longjmp should be&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// performed.&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do_jump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;the_cleanup_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_jump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;longjmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;might_throw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cleanup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;the_cleanup_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Catch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setjmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_jump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;throw_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;exception caught&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_jump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;do more stuff after having caught the exception&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And running it, we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plain&quot;&gt;exception caught
do more stuff after having caught the exception
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voilà! We have caught a C++ exception in C.&lt;/p&gt;

&lt;p&gt;OK, are we done?&lt;/p&gt;

&lt;p&gt;No! This result might be good enough, but I am still not satisfied. We have successfully &lt;em&gt;stopped&lt;/em&gt; an exception in C code, but we don't actually &lt;em&gt;get&lt;/em&gt; the thing that was thrown.
All we know in our &quot;exception handler&quot; is an exception was thrown, but not what the exception is. This is quite useless.&lt;/p&gt;

&lt;p&gt;So, can we retrieve the thrown exception?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Maybe&lt;/em&gt;. We will continue in part 2.&lt;/p&gt;</content><author><name></name></author><category term="Programming language" /><summary type="html">Hold on! Before you call me crazy, please let me clarify. Yes, I am going to tell you how to handle C++ exceptions in C code, but don't worry, I know this is a terrible idea, and (hopefully) no one is actually going to do that.</summary></entry><entry><title type="html">How you could have come up with Paxos yourself</title><link href="https://explain.yshui.dev/distributed%20system/2020/09/20/paxos.html" rel="alternate" type="text/html" title="How you could have come up with Paxos yourself" /><published>2020-09-20T00:00:00-05:00</published><updated>2020-09-20T00:00:00-05:00</updated><id>https://explain.yshui.dev/distributed%20system/2020/09/20/paxos</id><content type="html" xml:base="https://explain.yshui.dev/distributed%20system/2020/09/20/paxos.html">&lt;p&gt;In the field of computer science, the Paxos algorithm is notorious for how difficult it is to understand. I had to learn the Paxos algorithm in my distributed systems class. I even have &quot;implemented&quot; it by translating Leslie Lamport's TLA+ to Python. But I didn't understand it until much much later.&lt;/p&gt;

&lt;p&gt;Now I have a better understanding of Paxos than I used to, I want to explain it to other people. Not because I'd like to help people, rather, I find that explaining things is a very good way to find blind spots in my own understanding.&lt;/p&gt;

&lt;p&gt;So, where do we start? Personally, I dislike explanations that start with a step-by-step breakdown of the algorithm, followed by a proof of why those steps do what they claim to do. Instead, I much prefer to start with the problem the algorithm tries to solve, then iteratively come up with a solution together with the reader. So that's what I am going to do. And now you understand the title.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Small disclaimer:&lt;/em&gt; The glossaries used in this article is different from what is commonly used for Paxos. I just picked the ones that made the most sense for my narrative.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The problem&lt;/h2&gt;

&lt;p&gt;The distributed consensus problem is widely useful, so the reader probably doesn't need to be motivated. Here I will just simply state the problem.&lt;/p&gt;

&lt;p&gt;There is a group of agents (let's call them $\sc{CLIENT}s$), who want to choose a number among their selections. Any number is fine, as long as everyone agrees on the same number.&lt;/p&gt;

&lt;p&gt;Here, there are a few assumptions we will make to make this problem meaningful:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;All the agents - including but not limited to the $\sc{CLIENT}s$, as we will add more types of agents later - are well-behaved. Meaning they all execute the prescribed algorithms faithfully, and don't maliciously try to trick other agents. (If you like jargons: Byzantine failures don't occur.)&lt;/li&gt;
  &lt;li&gt;Agents can talk to each other by sending each other messages, but the messages they send to each other could take arbitrarily long before reaching their destination, and might get lost (but never altered).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The agents could also &quot;fail&quot;. However, failing is equivalent to all messages sent to/from that agent being lost forever. So whether we have this assumption or not won't change the algorithm we come up with.&lt;/p&gt;

&lt;p&gt;Also, to not complicate things, we are only solving the &quot;single-round&quot; consensus problem in this article, meaning as the output of this algorithm, all of the $\sc{CLIENT}s$ will get a single number which they agree on.&lt;/p&gt;

&lt;h2 id=&quot;solution-searching-adventure&quot;&gt;Solution searching adventure&lt;/h2&gt;

&lt;h3 id=&quot;iteration-0&quot;&gt;Iteration 0&lt;/h3&gt;

&lt;p&gt;When trying to solve a complex problem such as this one, it's usually a good idea to start by simplifying the problem.
As a start, let's just ignore the need to be reliable entirely.&lt;/p&gt;

&lt;p&gt;If we throw reliability out the window, it should be easy to come up with a very simple solution: we add an agent (let's call it $\sc{COORDINATOR}$).
The $\sc{CLIENTS}$ send whatever number they pick to the $\sc{COORDINATOR}$ in a $\sc{PROPOSAL}(client_i, x)$ message, where $x$ is the number
proposed by the $i$-th $\sc{CLIENT}$. The $\sc{COORDINATOR}$ picks an arbitrary proposal (say, $x'$),
and informs the other $\sc{CLIENT}s$ about this decision.
Specifically, the $\sc{COORDINATOR}$ will just reply with a $\sc{CHOSEN}(x')$ message to all the $\sc{PROPOSAL}(\ldots)$ messages it has
received and will receive.&lt;/p&gt;

&lt;p&gt;If we assume no messages ever get lost, it is quite easy to see that every $\sc{CLIENT}$ will get a number. And because only one number is ever chosen, they will all get the same number.&lt;/p&gt;

&lt;p&gt;It is also easy to see why this solution is impractical: it has a single point of failure. Once the singular $\sc{COORDINATOR}$ fails, no further progress can be made.&lt;/p&gt;

&lt;h3 id=&quot;iteration-1&quot;&gt;Iteration 1&lt;/h3&gt;

&lt;p&gt;To improve this almost looks easy at first glance: just add more $\sc{COORDINATOR}s$!&lt;/p&gt;

&lt;p&gt;Sure, more $\sc{COORDINATOR}s$ would remove the single point of failure. However, if there are more than one $\sc{COORDINATOR}s$, they might individually make different decisions, which results in the $\sc{CLIENT}s$ having disagreement.&lt;/p&gt;

&lt;p&gt;What if we let the $\sc{COORDINATOR}s$ reach an agreement among themselves before responding? But wait, doesn't that sound familiar? Having a group of agents reaching an agreement, that's exactly what we added the $\sc{COORDINATOR}s$ to solve. We just made the problem cyclic.&lt;/p&gt;

&lt;p&gt;Let's take a step back. Is there a way for the clients to reach an agreement without having the $\sc{COORDINATOR}s$ communicate with each other?&lt;/p&gt;

&lt;p&gt;In other words, among the decisions of the $\sc{COORDINATOR}s$, is there an deterministic algorithm to pick out a specific one that is robust against message losses?&lt;/p&gt;

&lt;p&gt;This might sound hard, but it's actually quite simple: pick the decision that is backed by more than half of the $\sc{COORDINATOR}s$.&lt;/p&gt;

&lt;p&gt;There can't be two decisions both with more than half of the $\sc{COORDINATOR}s$ backing them; and if a decision doesn't have that many $\sc{COORDINATOR}s$ backing it, it won't appear to have more backing $\sc{COORDINATOR}s$ through message losses.&lt;/p&gt;

&lt;p&gt;Since this approach resembles a majority vote, let's call $\sc{COORDINATOR}$ decisions $\sc{VOTE}(coord_i, x)$ from now on, where $x$ is the number picked by the $i$-th $\sc{COORDINATOR}$. Each $\sc{COORDINATOR}$ has a single vote, because each of them only makes a single decision.&lt;/p&gt;

&lt;p&gt;Obviously, our solution cannot be infinitely reliable. If more than half of the $\sc{COORDINATOR}s$ went down, there will never be a majority reached. But this is already vastly better than our first solution, and the reliability scales with the number of $\sc{COORDINATOR}s$. So we will call it good enough.&lt;/p&gt;

&lt;p&gt;Sadly, this solution doesn't actually work: there might not be a majority at all! For example, it's possible that three of the proposals each get a third of the votes. We would have a stalemate in that case.&lt;/p&gt;

&lt;h3 id=&quot;iteration-2&quot;&gt;Iteration 2&lt;/h3&gt;

&lt;p&gt;Again, a solution seems straightforward: just try again in case of a stalemate.&lt;/p&gt;

&lt;p&gt;But then again, things aren't that simple.&lt;/p&gt;

&lt;p&gt;First of all, the $\sc{COORDINATOR}s$ need to be made aware of a retry. Otherwise, because each $\sc{COORDINATOR}$ only has one vote, they won't be able to vote again even if the $\sc{CLIENT}s$ retry.&lt;/p&gt;

&lt;p&gt;To do that, we attach an attempt id to all the messages sent. i.e. $\sc{PROPOSAL}(client_i, x)$ becomes $\sc{PROPOSAL}(\#attempt, client_i, x)$, and so forth. Each time a $\sc{CLIENT}$ retries, it bumps $\#attempt$ to the maximum $\#attempt$ it knows of plus 1. And the $\sc{COORDINATOR}s$ should only responds to messages with the most recent $\#attempt$.&lt;/p&gt;

&lt;p&gt;Hopefully the intent of the $\#attempt$ number is clear. (&lt;a href=&quot;https://github.com/yshui/explain-algorithms/issues/new&quot;&gt;Let me know&lt;/a&gt; if not.)&lt;/p&gt;

&lt;p&gt;Are we good now? Unfortunately, no. Consider this scenario:&lt;/p&gt;

&lt;p&gt;There were 2 clients. They proposed their numbers, the $\sc{COORDINATOR}$ voted on them and all agreed on a single number, $x_1$, all is good. But, all of the $\sc{VOTE}(\ldots)$ messages got lost on the way to $client_2$, while $client_1$ received all of the messages just fine. At this point, $client_1$ thought $x_1$ is the number, but $client_2$ went on to retry. The $\sc{COORDINATOR}s$ voted again, and got $x_2$. This time, all the messages sent to $client_1$ got lost.&lt;/p&gt;

&lt;p&gt;And behold, we got the two clients to disagree.&lt;/p&gt;

&lt;p&gt;There is an important insight to be had here. Whenever a $\sc{COORDINATOR}$, say $coord_i$, sends out a $\sc{VOTE}(\ldots, coord_i, x)$, there is a chance that some $\sc{CLIENT}$ would adopt $x$. If $coord_i$ ever sends out two votes with different $x$, there is a chance that some of the $\sc{CLIENT}s$ would disagree.&lt;/p&gt;

&lt;p&gt;In other words, once a $\sc{COORDINATOR}$ has revealed its vote, it has to stick to it.&lt;/p&gt;

&lt;p&gt;This seems to run contrary to our attempt: if the $\sc{COORDINATOR}s$ cannot change their votes, what's the point of retrying? A stalemate will be a stalemate forever.&lt;/p&gt;

&lt;p&gt;Looks like we reached a dead end with this type of voting. It appears the problem stems from the fact that the $\sc{COORDINATOR}s$ have to commit to their votes.&lt;/p&gt;

&lt;p&gt;So, what if we introduce a form of non-commitment voting?&lt;/p&gt;

&lt;h3 id=&quot;iteration-3&quot;&gt;Iteration 3&lt;/h3&gt;

&lt;p&gt;Let's explore this idea. Say, the $\sc{COORDINATOR}s$ could now send a $\sc{TENTATIVE}\sc{VOTE}(\#attempt, coord_i, x)$ message, to tentatively vote for $x$.&lt;/p&gt;

&lt;p&gt;Obviously, the $\sc{CLIENT}s$ couldn't adopt $x$ right away. So what's this vote good for?&lt;/p&gt;

&lt;p&gt;Ah, right, it could get us to a majority.&lt;/p&gt;

&lt;p&gt;It is correct that tentative votes don't lead directly to an agreement among $\sc{CLIENT}s$, but it can show us when a majority has formed among the $\sc{COORDINATOR}s$.&lt;/p&gt;

&lt;p&gt;Once a $\sc{CLIENT}$ sees a majority tentative vote, it can then message the $\sc{COORDINATOR}s$ to ask for an actual vote. (Let's call this message $\sc{PLEASE}\sc{VOTE}(\#attempt, client_i)$). Intuitively, the $\sc{COORDINATOR}s$ have to make the same vote in the actual vote as their tentative votes.&lt;/p&gt;

&lt;p&gt;If all goes well, we would get a majority and an agreement. If there is no majority, the $\sc{COORDINATOR}s$ won't even start a vote, so they are free to change their mind. So the $\sc{CLIENT}s$ could start another attempt which might have a different outcome.&lt;/p&gt;

&lt;p&gt;What if things don't go well? What if the $\sc{PLEASE}\sc{VOTE}$ messages weren't received by some of the $\sc{COORDINATOR}s$?
In that case, some of the $\sc{COORDINATOR}s$ would have voted, and their decisions cannot be changed. That is to say, in all subsequent attempts, these $\sc{COORDINATOR}s$ will always vote for what they have voted for, whether it's a tentative vote, or the actual vote. But that doesn't create a problem for us. There was a majority in the tentative votes, and now we solidified part of the tentative votes. There is at least one way we can still reach a majority in the next round: everyone votes the same as they did in this round. And we can prove this inductively for all future rounds.&lt;/p&gt;

&lt;p&gt;From this, we can have a rough image of how the algorithm functions: as attempts are being made, more and more $\sc{COORDINATOR}s$ start to make up their mind which number they will commit to, while making sure a majority could still be reached. Eventually, after all the $\sc{COORDINATOR}s$ have made up their minds, by induction there must be a majority among them. From that point on, they will just repeatedly broadcast this decision to the $\sc{CLIENT}s$, until all the $\sc{CLIENT}s$ have got that message.&lt;/p&gt;

&lt;p&gt;And Viola, we have a working algorithm.&lt;/p&gt;

&lt;h3 id=&quot;the-actual-algorithm&quot;&gt;The actual algorithm&lt;/h3&gt;

&lt;p&gt;Let's clean up our thoughts, and condense the description of our algorithm so it's easy to understand.&lt;/p&gt;

&lt;p&gt;First, there is the $\#attempt$ number that is attached to every message. This number is bumped every time a new attempt is made. If a $\sc{CLIENT}$ sees a message with a $\#attempt$ bigger then its most recent $\#attempt$, it knows a new attempt has been initiated, so it would abort its current attempt and participate in the newer one. If a $\sc{COORDINATOR}$ sees a message with a $\#attempt$ smaller than the biggest $\#attempt$ it has ever seen, it would know that message is stale, so it will drop the message.&lt;/p&gt;

&lt;p&gt;With that out of the way, let's describe what happens in an attempt.&lt;/p&gt;

&lt;p&gt;Each attempt can be split into two phases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Phase 1:&lt;/strong&gt; The $\sc{CLIENT}s$ each send its $\sc{PROPOSAL}(\ldots)$ to the $\sc{COORDINATOR}s$. The $\sc{COORDINATOR}s$ reply with a $\sc{TENTATIVE}\sc{VOTE}(\ldots, x)$. Each $\sc{CLIENT}$ waits for the tentative votes until they reach a majority. If a majority is not reached, retry.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Phase 2:&lt;/strong&gt; If a majority is reached, the $\sc{CLIENT}s$ send $\sc{PLEASE}\sc{VOTE}$, and the $\sc{COORDINATOR}s$ actually vote. Their actual votes would be the same as their respective tentative votes. Each $\sc{CLIENT}$ waits for the votes until they reach a majority, and then adopt the majority number.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;back-to-paxos&quot;&gt;Back to Paxos&lt;/h2&gt;

&lt;p&gt;Our algorithm does look a bit different from the official Paxos. For one, the name of the agents are different. What we call $\sc{CLIENT}s$, Lamport calls $\sc{PROPOSER}s$; and $\sc{COORDINATOR}s$, $\sc{ACCEPTOR}s$.&lt;/p&gt;

&lt;p&gt;Besides that, there are protocol differences too.&lt;/p&gt;

&lt;p&gt;Firstly, the $\sc{COORDINATOR}s$ don't have to send the $\sc{TENTATIVE}\sc{VOTE}(\ldots)$ to everyone, they just need to send it to the $\sc{CLIENT}$ they agree with. This way we won't have every $\sc{CLIENT}s$ sending $\sc{PLEASE}\sc{VOTE}$ at the same time, that would be inefficient.&lt;/p&gt;

&lt;p&gt;After, we notice that the proposed number is unnecessarily sent multiple times in phase 1 and phase 2. The phase 1 is used to reach a majority, the proposed number is not actually important in that phase. So we remove the $x$ from $\sc{PROPOSAL}$; and in $\sc{TENTATIVE}\sc{VOTE}$, instead voting for a number, they vote for a $\sc{CLIENT}$, by sending the tentative vote only to that $\sc{CLIENTS}$. Finally, after a client received a majority of tentative votes, it sends a $\sc{PLEASE}\sc{VOTE}(x)$, so all the $\sc{COORDINATOR}s$ got that message will vote $x$. Of course, if a $\sc{COORDINATOR}$ has already voted in a previous round, it has to tell the $\sc{CLIENT}$, so it could pick the already voted $x$, otherwise its $\sc{PLEASE}\sc{VOTE}(x)$ will be wasted, as the $\sc{COORDINATOR}s$ couldn't change their minds.&lt;/p&gt;

&lt;p&gt;(The modified algorithm has slightly better property. In our algorithm, we just make sure a majority is still possible after each attempt; in Paxos, each round the $\sc{COORDINATOR}s$ that vote will all vote for the same number.)&lt;/p&gt;

&lt;p&gt;With this little changes, we can map our algorithm back to Paxos:&lt;/p&gt;

&lt;p&gt;Agents:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\sc{CLIENT}$ =&amp;gt; $\sc{PROPOSER}$ (which makes proposals) and $\sc{LEARNER}$ (which adopts the resulting number)&lt;/li&gt;
  &lt;li&gt;$\sc{COORDINATOR}$ =&amp;gt; $\sc{ACCEPTOR}$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Messages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\sc{PROPOSAL}(\#attempt, client_i)$ =&amp;gt; $\sc{PREPARE}(\#attempt, client_i)$&lt;/li&gt;
  &lt;li&gt;$\sc{TENTATIVE}\sc{VOTE}(\#attempt, coord_i)$ =&amp;gt; $\sc{PROMISE}(\#attempt, coord_i)$&lt;/li&gt;
  &lt;li&gt;$\sc{PLEASE}\sc{VOTE}(\#attempt, client_i, x)$ =&amp;gt; $\sc{ACCEPT}(\#attempt, client_i, x)$&lt;/li&gt;
  &lt;li&gt;$\sc{VOTE}(\#attempt, coord_i, x)$ =&amp;gt; $\sc{ACCEPTED}(\#attempt, coord_i, x)$&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Distributed system" /><summary type="html">In the field of computer science, the Paxos algorithm is notorious for how difficult it is to understand. I had to learn the Paxos algorithm in my distributed systems class. I even have &quot;implemented&quot; it by translating Leslie Lamport's TLA+ to Python. But I didn't understand it until much much later.</summary></entry></feed>